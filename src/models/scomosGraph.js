/**
 * SBML graph : accepts the data in scomos model format and plots the basic force directed graph
 * 				using d3 force layout
 **/
//TODO: need to change file name once the library name is decided
/**
 * Exports scomosGraph : creates d3 force graph based scomos data model
 * 	this graph  is strictly bound the scomos model data structure
 */
d3scomos.scomosGraph = function scomosGraph() {

	/** Some defaults change them accordingly **/
    var margin = {top: 20, right: 20, bottom: 40, left: 40},
        width = 1500,
        height = 1500;
    var svg, duration = 500;
    var graphRoot;
    var oneTime =false;
    /** export  to hold data specific to this graph instance **/
    var data = new ModelDataApi();
    //set oneTIme falg
    /** scomos selections object to manage node selection logic **/
    var selection;
    /** pan mode **/
    var __panMode = "PAN";//defaults to PAN another valid values will be select

    var zoomString;
    /** custom event dispatcher **/
    var dispatch = d3.dispatch('speciesHover','speciesClick',
    						   	'reactionHover','reactionClick',
    						   	'linkHover','linkClick',
    						   	'compartmentHover','compartmentClick',
                  	'covalentModificationClick');

    /**
     * draws chart on current data
     * @param injectInto {String} fully qualified d3 selector
     * @returns draws scomos model in specified html element
     */
    function __generateChart( injectInto,mode){
    	mode=mode||'REDRAW';
    	//mode is redraw remove previous drawings and selections
    	if(mode==='REDRAW'){
    		console.info('Redraw operation triggered');
    		init();
    		update();
    	}
    	else if(mode==='UPDATE'){
    		console.info('Update operation triggered');
    		update();
    	}

 function init(){
	 graphRoot = injectInto;
 	/** init selections **/
 	//selection = selection || new scomosSelections(injectInto);

 	//if(!data.getScomosSelection()){
 	data.storeScomosSelection(new scomosSelections(injectInto))
 	//}
 	selection = data.getScomosSelection();

     // add svg canvas to page
 	if(svg)
 		d3.select(injectInto).selectAll('svg').remove();
     svg = d3.select(injectInto)
         .append('svg');

     //if no data return this is required if graph is generated by non angular scripts
     //also this makes function testable
     if(!data.getHeight()) return;
     shapeUtil.initGradients(injectInto);
 	var boundaries = data.getBoundaryPoints();
 	svg.attr("height","700")
		.attr("width","100%");
 svg.attr("viewBox",boundaries.xNeg + " " + boundaries.yNeg + " " + data.getWidth() + " " + data.getHeight())
 	.attr("preserveAspectRatio", "xMinYMin meet");

 svg = svg.append('g');
 //develop your graph here

	var force=d3.layout.force()
			.size([200,200])
			.nodes([])
			.links([]);
 }
        //update height and widht
        /*svg.attr("height",boundaries.yPos-boundaries.yNeg + 150)
        	.attr("width",boundaries.xPos-boundaries.xNeg + 150);
        */

		//update the graph

		function update(){
			var speciesNodes = data.getSpeciesList(); //objToArrayOfObj(speciesData);
			var reactionNodes = data.getReactionList();
			var links = modelHelper.getEdgeList(reactionNodes,speciesNodes);
			var compartmentNodes = data.getCompartmentList();
			//var covalentModifications = modelHelper.getModifierList(speciesNodes)
			//svg.remove();
			var compartments = svg.selectAll('.compartment')
				.data(compartmentNodes)
				.enter()
				.append('g')
				.attr("transform", function(d)
		    		{ return "translate(" + d.position.iX + "," + d.position.iY + ")"; })
				.attr('class',function(d){return d.sId !== 'default' ? 'compartment' : 'defCompartment'});

			compartments.append('path')
				.attr('class', 'compartment-path')
				.attr('d',function(d){
					if(d.sType == "RECTANGULAR"){
						return shapeUtil.getRoundedRectWithTickness(d.iHeight, d.iWidth,10);
					}else if(d.sType == "CIRCULAR"){
						return shapeUtil.getEllipseWithTickness(d.iHeight, d.iWidth,10);
					}else{
						return shapeUtil.getRoundedRectWithTickness(d.iHeight, d.iWidth,10);
					}
					})
				.attr('style',function(d){
					//dont show  default compartment
					if(d.sId === 'default') return;
					return 'fill:'+'rgb('+d.color.iRed+','+d.color.iGreen+','+d.color.iBlue+')';
				});
			//compartments.on('mousedown',mouseDownOnCompartment);
			compartments.on('click',mouseClickedOnCompartment);//there is no special click event handler here
			compartments.on('mouseover', dispatch.compartmentHover);

			compartments.append('text')
			    .attr('text-anchor','middle')
			    //TODO: used static spacing for text make this configurable
			    .attr('x',function(d){return 0;})
			    .attr('y',function(d){return d.iHeight + 15})
			    .text(function(d){return d.sName})
			    .attr('class', 'text-node');


			var link = svg.selectAll('.link')
			.data(links)
			.enter()
			.append('path')
			.attr('class', 'link')
			.attr('d', function(d){return shapeUtil.getPathCoordsForLine(d.source, d.target, d.role)})
		    .attr("style", function(d){
		    	var marker;
		    	switch(d.role){
		    	case "Reactant":
		    		if(d.reversible)
					  marker = "marker-mid:url(#filledArrow);";
					break;
		    	case "Product":
					marker = "marker-mid:url(#filledArrow);";
					break;
		    	case "Modifier":
		    		if(d.modifierType === 'Inhibitor')
		    			marker = "marker-mid:url(#Line);";
		    		else //defaults ot activator
		    			marker = "marker-mid:url(#hollowArrow);";

		    		break;
				case "modifier_Inhibitor":
					marker = "marker-mid:url(#Line);";
					break;
				case "modifier_Activator":
					marker = "marker-mid:url(#hollowArrow);";
					break;
				default:
					marker = "";
				}

		    	return marker+" stroke:"+d.color+";";

		    })
		    .on('mousedown', mouseDownOnLink);
			link.on('click', dispatch.linkClick)
				.on('mouseover', dispatch.linkHover);

			var node = svg.selectAll('.species-node')
			    .data(speciesNodes)
			    .enter()
			    //.append('circle')
			    .append('g')
			    .attr('class','species-node');

			//add shape
		    node.append('path')
			    .attr('d',function(d){
			    	/*var shapeName = shapeUtil.resolveShape(d.enTypes);*/
			    	return d3scomos.getSymbol(d.sType,d);
			    })
			    .attr('class', 'species-path')
		    	.attr('fill','url(#speciesLinear)');
			    /*<text text-anchor="middle"
	          		x="60" y="75">A</text>
			     */
		    //add text

			node.append('text')
			    .attr('text-anchor','middle')
			    //TODO: used static spacing for text make this configurable
			    .attr('x',function(d){return d.iWidth/2;})
			    .attr('y',function(d){return d.iHeight + 15})
			    .text(function(d){return d.sName})
			    .attr('class', 'text-node');



			node.on('mouseover', dispatch.speciesHover)
		    	.on('click', clickOnSpecies);
		    //node.on('click',dispatch.speciesClick);

		    //dispatch.on("speciesClick",clickOnSpecies);

			    //transform these nodes there right posistions
		    node.attr("transform", function(d)
		    		{ return "translate(" + d.position.iX + "," + d.position.iY + ")"; });

		    //for each species-node, renders its COVALENT MODIFICATIONS
		    node.each(function(d){
				var thisNode = d3.select(this);
				var thisNodeData = d;
				//add svg elements
				var modifierListOfThisNode = modelHelper.getModifierListOfNode(thisNodeData);
				var modifierNodesOfThisNode = thisNode.selectAll('.modifier-node')
														.data(modifierListOfThisNode)
														.enter()
														.append('g').attr('class', 'modifier-node');
				modifierNodesOfThisNode.append('path')
										.attr('class', 'modifier-path')
										.attr('d', function(d){
														return shapeUtil.getEllipse(16, 16, d.parentSpecies.iWidth + 8 + d.pos*16, d.parentSpecies.iHeight - 8);
													});
										//.attr('style', "stroke-width: 1px; stroke: #000000; fill : #ffffff;");
				modifierNodesOfThisNode.append('text')
										.attr('x', function(d){return d.parentSpecies.iWidth + 12 + d.pos*16})
										.attr('y', function(d){return d.parentSpecies.iHeight + 4})
										.attr('class', "text-node")
										.text(function(d){return d.modificationType});
			});

		    var covalentModification = d3.selectAll('.modifier-node');
		    covalentModification.on('click', clickOnCovalentModification);
        //svg.selectAll('.reactionNode').remove();
			var reactions = svg.selectAll('.reaction-node')
				.data(reactionNodes)
				.enter()
				.append('g')
				.attr('class','reaction-node');

			reactions.append('path')
			    .attr('d',function(d){
			    	console.info("adding reaction : "+d.sId);
			    	return d3scomos.getSymbol('REACTION',d);
			    })
			    .attr('class', 'reaction-path')
				.attr('fill','url(#reactionLinear)');

			reactions.append('text')
			    .attr('text-anchor','start')
			    //TODO: used static locations assuming node size + 20 + 5 padding
			    .attr('x',function(d){return 25;})
			    //TODO: used static locations assuming node hiehgt + 20/2 + 5 padding
			    .attr('y',function(d){return 15})
			    .text(function(d){return d.sName})
			    .attr('class', 'text-node');

			reactions.attr("style", function(d){
											var reactionColor = "rgb("+d.color.iRed+","+d.color.iGreen+","+d.color.iBlue+")";
											return "fill: "+reactionColor+"; stroke: "+reactionColor+";";
										})
						 .on('mouseover', dispatch.reactionHover)
		    			 .on('click', clickOnReaction);
		    			 //.on('click', dispatch.reactionClick);


			//transform reaction nodes there positions
			reactions
				.attr("transform", function(d)
		    		{ return "translate(" + d.position.iX + "," + d.position.iY + ")"; });

			d3.select("svg").on('mousedown', mouseClickedOnSVG);

			d3.select("body")
			.on("keydown", function() {
				d3.event.stopPropagation();
				if(d3.event.keyCode==65 && d3.event.ctrlKey){
					d3.selectAll('.species-node').each(function(){
						var thisNode = d3.select(this);
						thisNode.classed('selected', true);
						selection.addNode(thisNode);
					});
					d3.selectAll('.reaction-node').each(function(){
						var thisNode = d3.select(this);
						thisNode.classed('selected', true);
						selection.addNode(thisNode);
					});
					d3.selectAll('.link').each(function(){
						var thisNode = d3.select(this);
						thisNode.classed('selected', true);
						selection.addNode(thisNode);
					});
					d3.selectAll('.compartment').each(function(){
						var thisNode = d3.select(this);
						thisNode.classed('selected', true);
						selection.addNode(thisNode);
					});
				}
			});
			var drag = d3.behavior.drag()
//		    .origin(function(d) {
//		    	return {x:d.position.iX,y:d.position.iY}; })
		    .on("dragstart", dragstarted)
		    .on("drag", dragged)
		    .on("dragend", dragended);

			//apply this drag on nodes
			node.call(drag);
			//apply this drag on reaction node
			reactions.call(drag);
			//apply drag to compartments
			compartments.call(drag);
			//apply drag to covalent modifications (these are not dragable; but used since selection logic is also part of drag logic)
			covalentModification.call(drag);
			//experimental zoom behaviour
			//TODO zoom bound are static make them configurable
			var zoomBehaviour = d3.behavior.zoom().
								scaleExtent([0.5, 10])
								.on("zoom", zoom);
			d3.select(injectInto).select('svg').call(zoomBehaviour);
		}


		function dragstarted(d) {
			d3.event.sourceEvent.stopPropagation();
			//treat drag started as the mouseDown event
			//do only selection logic in drag started no drag logic here
			//leave that to dragged method

			//ignore ctrl press in drag started
			if(!d3.event.sourceEvent.ctrlKey){
				//deselect all if this is not selected one
				//if selected this could be the case of the drag
				//so let dragged or clicked event handle further state
				if(!d3.select(this).classed('selected')){
					d3.selectAll('.selected').classed('selected',false);
					//clean up the selection
					selection.clear();
				}
				modelHelper.selectNode(d3.select(this));
				selection.addNode(d3.select(this));
			}
		}
		var isDragged = false;
		function dragged(d) {

			//process drag only if true drag
			if(d3.event.dx != 0 || d3.event.dy != 0)
			{
				isDragged = true;
				if(d3.event.sourceEvent.ctrlKey){
					//mark this as selected
					modelHelper.selectNode(d3.select(this));
					selection.addNode(d3.select(this));
				}
				/*//make all selected dragging
				d3.selectAll('.selected').classed('dragging',true);
				//drag all selected but links
				d3.selectAll('.dragging').filter(function(){
					//remove lines from this selection
					return !d3.select(this).classed('link');
				})
				.each(function(d){
					d.position.iX = d3.event.dx + d.position.iX;
					d.position.iY = d3.event.dy + d.position.iY;
					d3.select(this).attr("transform", "translate(" + d.position.iX + "," + d.position.iY + ")")
				});*/
				var dragables = selection.getDraggableSelection();
				dragables.forEach(function(thisNode){
					var node = d3.select(thisNode[0][0]);
					//drag if neither an edge nor a covalent modification
					if(!node.classed('link') && !node.classed('modifier-node')){
						//console.info(node.attr('class'));
						node.classed('dragging',true);
					}
				});
				//console.info(d3.selectAll('.dragging'));
				d3.selectAll('.dragging').each(function(d){
					d.position.iX = d3.event.dx + d.position.iX;
					d.position.iY = d3.event.dy + d.position.iY;
					d3.select(this).attr("transform", "translate(" + d.position.iX + "," + d.position.iY + ")")
				})
				//update affecting links
				svg.selectAll('.link').attr('d', function(d){return shapeUtil.getPathCoordsForLine(d.source, d.target, d.role)});
			}
		}

		function dragended(d) {
			if(isDragged){
				isDragged=false;
				console.log("drag ended");
				//do not handle any selection logic in drag end only dragging logic
				d3.selectAll(".dragging").classed("dragging", false);
				//update parent child relationShip of dragged elements
				selection.updateDraggableSelection(data);
			}

		}

		//Zoom behaviour experimental
		function zoom() {
			//zoomBehaviour.translate([d3.event.sourceEvent.x, d3.event.sourceEvent.y]);//reset translate if any
			if(__panMode.toUpperCase() === "PAN"){
				//d3.event.stopPropagation();
				d3.select(injectInto).select('g')
					.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
				//store thsese zoom settings for refreshing the graph
				zoomString = "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")";
				data.storeZoom(zoomString);
			}
			if(__panMode.toUpperCase() === "SELECT"){
				d3.select(injectInto).select('g')
					.attr("transform","scale(" + d3.event.scale + ")");

				//store thsese zoom settings for refreshing the graph
				zoomString = "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")";
				data.storeZoom(zoomString);
				//.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
				//draw/update a selection rect
				/*if(!d3.select("#selection-rect")[0][0]){
					//add a rect at this point
					*//**
					 * <rect x="10" y="10" width="100" height="100" stroke="blue" fill="purple"
       fill-opacity="0.5" stroke-opacity="0.8"/>
					 *//*
					d3.select(injectInto)
						.select('svg')
						.select('g')
						.append("rect")
						.classed("selection-rect",true)
						.attr("x",function(){return d3.event.sourceEvent.clientX})
						.attr("y",function(){return d3.event.sourceEvent.clientY})
						.attr("height","100")
						.attr("height","200");
					console.log(d3.select(".selection-rect"));
				}
				else
					{
					var selectionRect = d3.select(".selection-rect");
					//upate dimenstins
					selectionRect.attr("height",function(){selectionRect.attr("y")-d3.event.sourceEvent.clientY});
					selectionRect.attr("width",function(){selectionRect.attr("x")-d3.event.sourceEvent.clientX});
					}*/
			}
			//zoom irrespectively
		}
		//TODO : create node lookup structure so that force layout can perform its calculations
		//force.start();

		/** this is added here for testing
		 * TODO find way to refactor this to seperate file
		 */
		/**
		 * scomosGraphBehaviours : refactored from scomosGraph to minimize the file size
		 * Will contain :
		 * 		various event handler functions
		 * 		d3 behaviours(drag,zoom) and handlers
		 * All these are re factored from scomosGraph so will be very specific to scomosGraph.
		 * Note : no need to write seperate test for these as these functions will be tested from scomosGraph_tests.js
		 */

		//function mouseDownOnSpecies(d){
		function clickOnSpecies(d){
			d3.event.stopPropagation();
			if (d3.event.defaultPrevented) return;
			//propagate this event one level above so that g element will handle it
			//fixes dragging problem
			//d3.event.stopPropagation();

			var thisSpecies = d3.select(this);
			if(!d3.event.ctrlKey){
				d3.selectAll('.selected').classed("selected", false);
				//clean up the selection
				selection.clear();
				thisSpecies.classed("selected", true);
				//clean up the selection
				selection.addNode(thisSpecies);
			}
			else{
				//toggle speciesSelection
				thisSpecies.classed('selected',!thisSpecies.classed('selected'));
				//add to selection if it is selected
				if(thisSpecies.classed('selected'))
					selection.addNode(thisSpecies);
				else
					selection.removeNode(thisSpecies);
			}
			//dispatch.on("speciesClick");
			dispatch.speciesClick(d);
		}

		function clickOnCovalentModification(d,i){
			d3.event.stopPropagation();
			if (d3.event.defaultPrevented) return;

			var thisModification = d3.select(this);
			if(!d3.event.ctrlKey){
				d3.selectAll('.selected').classed("selected", false);
				//clean up the selection
				selection.clear();
				thisModification.classed("selected", true);
				//clean up the selection
				selection.addNode(thisModification);

			}
			else{
				//toggle speciesSelection
				thisModification.classed('selected',!thisModification.classed('selected'));
				//add to selection if it is selected
				if(thisModification.classed('selected'))
					selection.addNode(thisModification);
				else
					selection.removeNode(thisModification);
			}

            dispatch.covalentModificationClick(d,i)
		}

		//function mouseDownOnReaction(d){
		function clickOnReaction(d,i){
			d3.event.stopPropagation();
			if (d3.event.defaultPrevented) return;
			//propagate this event one level above so that g element will handle it
			//fixes dragging problem
			//d3.event.stopPropagation();

			var thisReaction = d3.select(this);
			if(!d3.event.ctrlKey){
				d3.selectAll('.selected').classed("selected", false);
				//clean up the selection
				selection.clear();
				thisReaction.classed("selected", true);
				selection.addNode(thisReaction);
			}
			else{
				//toggle reactionSelection
				thisReaction.classed('selected',!thisReaction.classed('selected'));

				//add to selection if it is selected
				if(thisReaction.classed('selected'))
					selection.addNode(thisReaction);
				else
					selection.removeNode(thisReaction);
			}
			//select edges involving this reaction
			d3.selectAll('.link').filter(function(thisLink){
				var _source = thisLink.source;
				var _target = thisLink.target;
				var thisID = thisReaction.datum().sId;
				return _source.sId === thisID || _target.sId === thisID;
			}).classed('selected',thisReaction.classed('selected')); //links follow the state of reaction node
			//dispatch click event for user defined hadlers
			dispatch.reactionClick(d,i);
		}

		function mouseDownOnLink(d){
		//function clickOnLink(d){
			//propagate this event one level above so that g element will handle it
			//fixes dragging problem
			d3.event.stopPropagation();
			//if (d3.event.defaultPrevented) return;

			var thisLink = d3.select(this);
			if(!d3.event.ctrlKey){
				//deselect all and select this link
				d3.selectAll('.selected').classed("selected", false);
				//clean up the selection
				selection.clear();
				thisLink.classed("selected", true);
				selection.addNode(thisLink);
			}
			else{
				//toggle link selection
				thisLink.classed('selected',!thisLink.classed('selected'));
				//add to selection if it is selected
				if(thisLink.classed('selected'))
					selection.addNode(thisLink);
				else
					selection.removeNode(thisLink);
			}
		}

		function mouseDownOnCompartment(d,i){
			d3.event.stopPropagation();
			/*if (d3.event.defaultPrevented) return;*/

/*			//expose event to external click handler
			dispatch.compartmentClick(d,i);*/
		}

		function mouseClickedOnCompartment(d,i){
			console.info("compartment clikced "+d.sId);
			d3.event.stopPropagation();
			if (d3.event.defaultPrevented) return;
			//propagate this event one level above so that g element will handle it
			//fixes dragging problem
			//d3.event.stopPropagation();

			var thisCompartment = d3.select(this);

			if(!d3.event.ctrlKey){
				d3.selectAll('.selected').classed("selected", false);
				//clean up the selection
				selection.clear();
				thisCompartment.classed("selected", true);
				//clean up the selection
				selection.addNode(thisCompartment);
			}
			else{
				//toggle speciesSelection
				thisCompartment.classed('selected',!thisCompartment.classed('selected'));
				//add to selection if it is selected
				if(thisCompartment.classed('selected'))
					selection.addNode(thisCompartment);
				else
					selection.removeNode(thisCompartment);
			}
			selection.updateDraggableSelection(data);
			selection.updateDraggableSelection(data);
			dispatch.compartmentClick(d,i);
		}
		function mouseClickedOnSVG(d){
			if (d3.event.defaultPrevented) return;
			d3.event.stopPropagation();
			if(__panMode.toUpperCase() === "SELECT"){
				d3.selectAll('.selected').classed("selected", false);
				//clean up the selection
				selection.clear();
			}
		}

		/*function mouseDownOnCanvas(d){
			;
		}*/
		/** handle selection if select mode and selection rects are found **/

		function mouseUpOnCanvas(d)
		{
			var selectionRect = d3.select("#selection-rect");
			//selectionRect.remove();
			console.info("mouse up on canvas");
		}
		//TODO : this is a temporary fix to detect dropping in canvas
		//after the drawing is done aupdate all canvases to actual draw size

		if( false/*data.getOnetime()*/){
			console.info('running one time compartment adjustment fix')
			data.setOnetime(false);
			d3.select(injectInto)
			.selectAll('.compartment')
			.each(function(d){
			var thisCompartment = d3.select(this);
			var thisData = thisCompartment.datum();
			var rect = d3.select(this).node().getBBox();

			/*
			 * 	height: 2005.953125
				width: 2496.21240234375
				x: -15.8125
				y: -0.0000026172481284447713
			 */
			try{
				thisData.iHeight = rect.height;
				thisData.iWidth = rect.width;
				/*thisData.position.iX = rect.x;
				thisData.position.iY = rect.y;*/
			}catch(error){
				console.error("failed one time bound update for " + thisData.sId);
			}
		});
		}
    }

    /** process current selection
     * this is method more angular specific going ahead needs refactor
     */
    function exports() {
    	/**//** this check is added to support angular specific selection
    	 * which have both html element and data embeded into them
    	 *//*
    	if(_selection.hasOwnProperty('each'))
    		{
		        _selection.each(function(_data) {
		        	*//** init this chart instance with new data **//*
		        	if(!_data || _data ==="")
		        		return;
		        	data = new ModelDataApi(_data);
		        	//_selection.call(__generateChart(_selection));
		        	__generateChart(_selection[0][0]);
		        });
    		}
    	else{
    		//handles non angular init calls
    		//pass on the reference of current DOM element for injecting chart into
    		__generateChart(_selection);
    	}*/
    }
    exports.width = function(_x) {
        if (!arguments.length) return width;
        width = parseInt(_x);
        return this;
    };
    exports.height = function(_x) {
        if (!arguments.length) return height;
        height = parseInt(_x);
        duration = 0;
        return this;
    };
    exports.ease = function(_x) {
        if (!arguments.length) return ease;
        ease = _x;
        return this;
    };
    exports.setPanMode = function(__mode){
    	__mode = __mode.toUpperCase();
    	switch (__mode) {
		case "PAN":
			__panMode = __mode;
			break;
		case "SELECT":
			__panMode = __mode;
			break;
		default:
			console.log("Invalid pan mode " + __mode + " defaulting mode PAN")
			__panMode = "PAN";
			break;
		}
    }
    /** accepts the modelData and initializes the modelData api with passed data **/
    exports.data = function(__modelData){
    	if(__modelData)
    		data.setData(__modelData);
    	return data;
    };

    /** accepts constructor param for selections object and exposes internal selection object **/
    exports.selections = function()
    {
    	return selection;
    }
    /** export chartGenerator **/
    exports.generate = function(__elem,__modelData){
    	if(__modelData)
    		data.setData(__modelData);
    	__generateChart(__elem);
    }
    exports.refresh = function(){
    	//this will select the nodes if any in selection
    	if(graphRoot){
    		console.info('Refresh operation triggered');
    		__generateChart(graphRoot,'UPDATE');
			selection.markSelected();
			if(svg){
				svg.attr("transform", data.getZoom());
			}
    	}

    }
    d3.rebind(exports, dispatch, 'on');
    return exports;
};
